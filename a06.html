<!DOCTYPE html>

<html lang="fa" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>جلسه 6</title>
</head>
<body dir="rtl" style="font-family:Tahoma">
    <h2>جلسه 6</h2>
    <p>
        بعد از نوشتن برنامه و اطمینان از صحت عملکرد آن، برای اینکه توسعه و نگهداری برنامه ساده شود
        آن را مجدداً سازماندهی می‌کنیم. این کار
        refactoring
        نامیده می‌شود. مثلاً برای استفاده از
        turtle
        ها، همیشه  لازم است پنجره‌ای ساخته شود و حداقل یک
        turtle
        ایجاد شود. می‌توانیم برای هر کدام از این کارها یک تابع ایجاد کنیم.
        همچنین اگر بخواهیم چند مستطیل رسم کنیم بهتر است تابعی برای این کار تعریف کنیم و آن را فراخوانی کنیم تا از تکرار کد جلوگیری شود.
        استفاده از تابع این مزیت را هم دارد که در صورت نیاز به تغییر، این کار فقط یک بار انجام می‌شود.
        <br /><br />
        این فایل‌ها را مشاهده کنید:
        L6_turtle1.py, L6_turtle2.py, L6_turtle3.py
    </p>
    <hr />
    <p>
        برنامه زیر یک جدول ضرب را چاپ می‌کند:
        <pre dir="ltr">
            for i in range(1, 10):
                for j in range(1, 10):
                    print(i * j, end=" ")
                print()
        </pre>
        در هر سطر  همه مضارب یک عدد چاپ می‌شود.
        این کار را می‌توان با استفاده از یک تابع انجام داد و در حلقه
        i
        آن تابع را فراخوانی کرد:
        <pre dir="ltr">
        def print_multiples(n):
            for j in range(1, 10):
                print(n * j, end=" ")
            print()

        for i in range(1, 10):
            print_multiples(i)
        </pre>
        برنامه فوق جدول ضرب اعداد 1 تا 9 را چاپ می‌کند. اگر بخواهیم به جای 9 مقدار دیگری قرار دهیم باید در دو جا عدد 9 را تغییر دهیم.
        اما با تعریف یک تابع دیگر و استفاده از پارامتری به نام
        high،
        فقط کافی است یک بار مقدار آن را تعیین می‌کنیم:
        <pre dir="ltr">
        def print_multiples(n, high):
            for j in range(1, high + 1):
                print(n * j, end="   ")
            print()

        def print_mult_table(high):
            for i in range(1, high + 1):
                print_multiples(i, high)

        print_mult_table(9)
        </pre>
        <hr />
    </p>
    <p>
        قبل از اختراع ماشین حساب و کامپیوتر محاسبه جذر به صورت دستی انجام می‌شد.
        نیوتن روشی تکراری را برای این منظور پیشنهاد کرد:
        <br />
        فرض کنید جذر عدد
        n
        را می‌خواهیم. ابتدا تقریبی از مقدار جذر مانند
        a
        را در نظر ‌می‌گیریم. سپس تقریب بهتری از جذر را با استفاده از فرمول
        <div dir="ltr" style="text-align:center">
            b = (a + n / a) / 2
        </div>
        محاسبه می‌کنیم. مقدار
        b
        را در
        a
        می‌گذاریم و فرایند را تکرار می‌کنیم.
        این کار را تا جایی تکرار می‌کنیم که شرط زیر برقرار شود:
        <div dir="ltr" style="text-align:center">
            |b - a| < 0.001
        </div>
        سعی کنید تابعی بنویسید که این روش را پیاده‌سازی کند.
        <br /><br />
        کد تابع در این فایل موجود است:
        L6_Newton.py
    </p>
    <hr />
    <p>
        خطاهای برنامه‌نویسی باگ نامیده می‌شوند و به فرایند پبدا کردن آنها دیباگ کردن گفته می‌شود.
        <br />
        یکی از راههای دیباگ کردن برنامه استفاده از دستورات
        print
        اضافه است. به این صورت که در جاهای لازم مقدار متغیرها را چاپ می‌کنیم تا از تغییرات آنها در طول برنامه آگاه شویم.
        <br />
        روش دیگر استفاده از امکانات یک  محیط توسعه یکپارچه 
        IDE (Integrated Development Environment)
        است.
        برای پایتون
        IDEهای
        زیادی وجود دارد.
        یکی از آنها
        PyScripter
        است که از آدرس زیر قابل دانلود است
        <div dir="ltr" style="text-align:center">
            <a href="https://sourceforge.net/projects/pyscripter/">PyScripter</a>
        </div>
    </p>
    <hr />
    <p>
        برای اطمینان از درستی برنامه باید آن را با ورودیهای مختلف آزمایش کنیم. به این کار تست برنامه می‌گویند.
        برای آزمایش حالتهای مختلف می‌توان از تست خودکار استفاده کرد.
        به این صورت که کدهای اضافه‌ای در برنامه برای تست آن نوشته می‌شود.
        مثلاً دو تابع زیر برای محاسبه قدرمطلق را در نظر بگیرید:
        <pre dir="ltr">
        def absolute_value(x):
            if x < 0:
                return -x
            else:
                return x

        def bad_absolute_value(x):
            if x < 0:
                return -x
            elif x > 0:
                return x
        </pre>
        تابع دوم برای مقدار 0 چیزی برنمی‌گرداند. بنابراین مقدار
        bad_absolute_value(0)
        برابر 0 نیست و  در نتیجه
        مقدار
        bad_absolute_value(0) == 0
        مقدار False
        را خواهد داشت.
        <br />
        با توجه به این نکته، در فایل
        L6_UnitTest.py
        یک تابع به نام
        test_suite
        تعریف شده است که دو تابع فوق را برای مقادیر مختلف تست می‌کند.
        تابعی به نام
        test
        نیز تعریف شده است که برای چاپ خط برنامه مورد استفاده قرار می‌گیرد.
        <br />
        توجه: اینجا دانستن نحوه چاپ شماره خط اهمیت ندارد.
    </p>

    <div style="text-align:center">
    </div>
</body>
</html>
